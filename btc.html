<!DOCTYPE html>
<!-- saved from url=(0038)https://xxnukertube.github.io/Bitcoin/ -->
<html lang="pt-BR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Gerador de Carteira Bitcoin Offline (Auditável)</title>
    <style>
        :root { --bg: #0f1115; --panel: #161b22; --text: #c9d1d9; --accent: #238636; --border: #30363d; --mono: 'Courier New', monospace; }
        body { background-color: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; padding: 20px; max-width: 900px; margin: 0 auto; }
        h1, h2, h3 { border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        .container { display: grid; gap: 20px; }
        .panel { background: var(--panel); border: 1px solid var(--border); padding: 20px; border-radius: 6px; }
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #8b949e; }
        input, select, textarea { width: 100%; padding: 10px; background: #0d1117; border: 1px solid #30363d; color: #fff; border-radius: 4px; font-family: var(--mono); box-sizing: border-box; }
        #mouse-area { height: 100px; border: 2px dashed var(--border); display: flex; align-items: center; justify-content: center; color: #8b949e; cursor: crosshair; margin-top: 10px; transition: background 0.2s; }
        #mouse-area.active { border-color: var(--accent); color: var(--accent); background: rgba(35, 134, 54, 0.1); }
        button { background: var(--accent); color: white; border: none; padding: 15px 30px; font-size: 16px; font-weight: bold; cursor: pointer; border-radius: 6px; width: 100%; margin-top: 20px; }
        button:hover { opacity: 0.9; }
        .output-block { margin-top: 10px; }
        .hash-display { font-family: var(--mono); word-break: break-all; font-size: 12px; color: #8b949e; background: #000; padding: 10px; border-radius: 4px; border-left: 3px solid var(--accent); }
        .index-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; margin-top: 15px; }
        .seed-index { background: #21262d; padding: 8px; text-align: center; border-radius: 4px; font-family: var(--mono); border: 1px solid var(--border); }
        .seed-index span { display: block; font-size: 10px; color: #8b949e; margin-bottom: 4px; }
        .seed-index strong { color: #58a6ff; font-size: 14px; }
        .warning { color: #f85149; font-size: 0.9em; margin-top: 5px; }
        progress { width: 100%; height: 10px; margin-top: 5px; }
    </style>
</head>
<body>

    <h1>Gerador de Cold Wallet Bitcoin (BIP-39/44)</h1>
    <p class="warning">⚠️ MODO OFFLINE OBRIGATÓRIO: Desconecte a internet antes de usar. Este código roda localmente.</p>

    <div class="container">
        
        <div class="panel">
            <h2>1. Coleta de Entropia (Aleatoriedade)</h2>
            <div class="input-group">
                <label>Tamanho da Seed (Palavras/Bits)</label>
                <select id="bits-select">
                    <option value="128">128 bits (12 Palavras / Índices)</option>
                    <option value="256" selected="">256 bits (24 Palavras / Índices)</option>
                </select>
            </div>
            
            <div class="input-group">
                <label>Senha Forte (Sal manual)</label>
                <input type="password" id="user-pass" placeholder="Digite algo único...">
            </div>

            <div class="input-group">
                <label>Objetivo do Bitcoin (Motivação filosófica)</label>
                <input type="text" id="user-reason" placeholder="Ex: Soberania financeira...">
            </div>

            <div class="input-group">
                <label>Nome do primeiro animal de estimação</label>
                <input type="text" id="user-pet" placeholder="Nome...">
            </div>

            <div class="input-group">
                <label>Entropia Física (Mova o mouse aqui dentro)</label>
                <div id="mouse-area">Passe o mouse aqui para gerar caos</div>
                <progress id="entropy-progress" value="0" max="100"></progress>
                <small id="entropy-count">Eventos coletados: 0</small>
            </div>
            
            <button onclick="generateWallet()">GERAR CARTEIRA OFFLINE</button>
        </div>

        <div class="panel" id="audit-panel" style="display:none;">
            <h2>2. Auditoria de Entropia (Transparência)</h2>
            
            <div class="output-block">
                <label>Entropia do Sistema (window.crypto - Hex)</label>
                <div class="hash-display" id="out-sys-entropy">Aguardando...</div>
            </div>

            <div class="output-block">
                <label>Entropia do Usuário (Processada/Hash SHA-256)</label>
                <div class="hash-display" id="out-user-entropy">Aguardando...</div>
                <small>Derivada de: Mouse(x,y,t,acc) XOR Teclas XOR Inputs</small>
            </div>

            <div class="output-block">
                <label>SEED FINAL (Entropia Mestra - 256 bits)</label>
                <div class="hash-display" style="color: #58a6ff;" id="out-final-seed">Aguardando...</div>
            </div>
        </div>

        <div class="panel" id="bip39-panel" style="display:none;">
            <h2>3. Backup BIP-39 (Índices)</h2>
            <p style="font-size: 0.9em;">Anote estes números na ordem exata. Eles representam sua seed. <br><strong>Intervalo: 1 a 2048</strong> (Compatível com wordlist padrão).</p>
            <div class="index-grid" id="seed-grid"></div>
        </div>

        <div class="panel" id="keys-panel" style="display:none;">
            <h2>4. Chaves Derivadas (Legacy P2PKH)</h2>
            
            <div class="output-block">
                <label>Chave Privada (Hexadecimal)</label>
                <div class="hash-display" style="color: #f85149;" id="out-priv-hex">***</div>
            </div>

            <div class="output-block">
                <label>Chave Privada (WIF - Wallet Import Format)</label>
                <div class="hash-display" style="color: #f85149;" id="out-priv-wif">***</div>
            </div>

            <div class="output-block">
                <label>Chave Pública (Comprimida)</label>
                <div class="hash-display" id="out-pub-hex">***</div>
            </div>

            <div class="output-block">
                <label>Endereço Bitcoin</label>
                <div class="hash-display" style="border-left-color: #f7b926; color: #fff; font-size: 14px;" id="out-address">***</div>
            </div>
        </div>

    </div>

<script>
/* ==========================================================================
   MÓDULO DE CRIPTOGRAFIA (SEM LIBS)
   Contém: BigInt Math, Secp256k1, SHA-256 Helper, RIPEMD-160, Base58
   ========================================================================== */

// --- 1. Utilitários ---
const bufferToHex = (buffer) => Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
const hexToBytes = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
const textToBytes = (text) => new TextEncoder().encode(text);

// --- 2. Hashing (SHA-256 via WebCrypto) ---
async function sha256(dataBuffer) {
    return window.crypto.subtle.digest('SHA-256', dataBuffer);
}

// --- 3. RIPEMD-160 (Implementação Compacta JS Puro) ---
// Fonte adaptada de implementações open-source padrão para funcionamento browser-side
function ripemd160(input) {
    const zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    const zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    const sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    const sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    const hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
    const hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];
    let h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

    // Pad
    let msg = Array.from(input);
    const len = msg.length * 8;
    msg.push(0x80);
    while ((msg.length % 64) !== 56) msg.push(0);
    msg.push(len & 0xff, (len >>> 8) & 0xff, (len >>> 16) & 0xff, (len >>> 24) & 0xff, 0, 0, 0, 0);

    for (let i = 0; i < msg.length; i += 64) {
        const w = new Uint32Array(16);
        for (let j = 0; j < 16; j++) w[j] = msg[i + j * 4] | (msg[i + j * 4 + 1] << 8) | (msg[i + j * 4 + 2] << 16) | (msg[i + j * 4 + 3] << 24);

        let al = h[0], bl = h[1], cl = h[2], dl = h[3], el = h[4];
        let ar = h[0], br = h[1], cr = h[2], dr = h[3], er = h[4];

        for (let j = 0; j < 80; j++) {
            let tl = (al + ((j < 16) ? (bl ^ cl ^ dl) : (j < 32) ? ((bl & cl) | (~bl & dl)) : (j < 48) ? ((bl | ~cl) ^ dl) : ((bl & dl) | (cl & ~dl))) + w[zl[j]] + hl[Math.floor(j / 16)]) | 0;
            tl = ((tl << sl[j]) | (tl >>> (32 - sl[j]))) + el;
            al = el; el = dl; dl = (cl << 10) | (cl >>> 22); cl = bl; bl = tl;

            let tr = (ar + ((j < 16) ? ((br & (cr ^ dr)) ^ dr) : (j < 32) ? ((br | ~cr) ^ dr) : (j < 48) ? ((br & ~dr) | (cr & dr)) : (br ^ (cr | ~dr))) + w[zr[j]] + hr[Math.floor(j / 16)]) | 0;
            tr = ((tr << sr[j]) | (tr >>> (32 - sr[j]))) + er;
            ar = er; er = dr; dr = (cr << 10) | (cr >>> 22); cr = br; br = tr;
        }

        let t = (h[1] + cl + dr) | 0; h[1] = (h[2] + dl + er) | 0; h[2] = (h[3] + el + ar) | 0; h[3] = (h[4] + al + br) | 0; h[4] = (h[0] + bl + cr) | 0; h[0] = t;
    }

    const out = new Uint8Array(20);
    for (let i = 0; i < 5; i++) {
        out[i*4] = h[i] & 0xff; out[i*4+1] = (h[i] >>> 8) & 0xff;
        out[i*4+2] = (h[i] >>> 16) & 0xff; out[i*4+3] = (h[i] >>> 24) & 0xff;
    }
    return out;
}

// --- 4. Secp256k1 (Curva Elíptica via BigInt) ---
const SECP256K1 = {
    p: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2Fn, // Campo Primo
    n: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141n, // Ordem
    gx: 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798n, // Ponto Gerador X
    gy: 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8n, // Ponto Gerador Y
    
    mod: (a, b = SECP256K1.p) => { const result = a % b; return result >= 0n ? result : result + b; },
    
    // Inverso Modular (Euclides Estendido)
    modInverse: (v, n = SECP256K1.p) => {
        let [l, h] = [0n, 1n];
        let [low, high] = [n, v];
        while (high !== 0n) {
            const q = low / high;
            [low, high] = [high, low - q * high];
            [l, h] = [h, l - q * h];
        }
        return SECP256K1.mod(l, n);
    },

    // Adição de Pontos
    pointAdd: (p1, p2) => {
        if (!p1) return p2;
        if (!p2) return p1;
        const [x1, y1] = p1;
        const [x2, y2] = p2;
        if (x1 === x2 && y1 !== y2) return null;
        const m = (x1 === x2) 
            ? SECP256K1.mod(3n * x1 * x1 * SECP256K1.modInverse(2n * y1)) 
            : SECP256K1.mod((y2 - y1) * SECP256K1.modInverse(x2 - x1));
        const x3 = SECP256K1.mod(m * m - x1 - x2);
        const y3 = SECP256K1.mod(m * (x1 - x3) - y1);
        return [x3, y3];
    },

    // Multiplicação Escalar (Double-and-Add)
    pointMultiply: (scalar, point = [SECP256K1.gx, SECP256K1.gy]) => {
        let result = null;
        let addend = point;
        while (scalar > 0n) {
            if (scalar & 1n) result = SECP256K1.pointAdd(result, addend);
            addend = SECP256K1.pointAdd(addend, addend);
            scalar >>= 1n;
        }
        return result;
    }
};

// --- 5. Base58Check ---
const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function toBase58(buffer) {
    let num = 0n;
    for (const byte of buffer) num = (num << 8n) + BigInt(byte);
    let str = '';
    while (num > 0n) {
        const rem = num % 58n;
        num = num / 58n;
        str = BASE58_ALPHABET[Number(rem)] + str;
    }
    // Leading zeros
    for (const byte of buffer) {
        if (byte !== 0) break;
        str = '1' + str;
    }
    return str;
}

/* ==========================================================================
   LÓGICA DO APLICATIVO
   ========================================================================== */

let mouseEntropy = [];
let keyEntropy = [];

// Listeners de Entropia
document.getElementById('mouse-area').addEventListener('mousemove', (e) => {
    if (mouseEntropy.length < 500) {
        const t = Date.now();
        // Coleta posição, tempo, e "velocidade" (delta)
        mouseEntropy.push(e.clientX, e.clientY, t, e.movementX, e.movementY);
        updateEntropyDisplay();
    } else {
        document.getElementById('mouse-area').classList.remove('active');
        document.getElementById('mouse-area').innerText = "Entropia Máxima Coletada!";
    }
});

document.addEventListener('keydown', (e) => {
    keyEntropy.push(e.key.charCodeAt(0), Date.now());
});

function updateEntropyDisplay() {
    const count = mouseEntropy.length;
    document.getElementById('entropy-progress').value = Math.min(count, 500) / 5;
    document.getElementById('entropy-count').innerText = `Eventos coletados: ${count}/500`;
    document.getElementById('mouse-area').classList.add('active');
}

async function generateWallet() {
    // 1. Validar Entradas
    const pass = document.getElementById('user-pass').value;
    const reason = document.getElementById('user-reason').value;
    const pet = document.getElementById('user-pet').value;
    
    if (mouseEntropy.length < 50) {
        alert("Por favor, mova o mouse mais dentro da área indicada para gerar entropia.");
        return;
    }

    // 2. Processar Entropia do Usuário
    const encoder = new TextEncoder();
    const userBytes = new Uint8Array([
        ...encoder.encode(pass),
        ...encoder.encode(reason),
        ...encoder.encode(pet),
        ...new Uint8Array(new Uint32Array(mouseEntropy).buffer),
        ...new Uint8Array(new Uint32Array(keyEntropy).buffer)
    ]);

    // Hash da entropia do usuário (User Entropy)
    const userHashBuffer = await sha256(userBytes);
    const userHashArr = new Uint8Array(userHashBuffer);

    // 3. Entropia do Sistema (CSPRNG)
    const sysEntropyArr = new Uint8Array(32); // 256 bits
    window.crypto.getRandomValues(sysEntropyArr);

    // 4. Fusão de Entropia (XOR + Multiplicação Modular simples para mistura)
    const finalSeedArr = new Uint8Array(32);
    for (let i = 0; i < 32; i++) {
        // XOR simples entre sistema e usuário
        let val = sysEntropyArr[i] ^ userHashArr[i]; 
        // Adiciona um pouco de não-linearidade posicional
        val = (val + i) % 256; 
        finalSeedArr[i] = val;
    }

    // Hash Final para garantir distribuição uniforme (Seed Mestra)
    const finalHashBuffer = await sha256(finalSeedArr);
    const finalHash = new Uint8Array(finalHashBuffer);

    // Exibir Auditoria
    document.getElementById('audit-panel').style.display = 'block';
    document.getElementById('out-sys-entropy').innerText = bufferToHex(sysEntropyArr);
    document.getElementById('out-user-entropy').innerText = bufferToHex(userHashArr);
    document.getElementById('out-final-seed').innerText = bufferToHex(finalHash);

    // 5. BIP-39 (Geração de Índices)
    // Se 12 palavras = 128 bits entropia + 4 bits checksum
    // Se 24 palavras = 256 bits entropia + 8 bits checksum
    const bitsRequested = parseInt(document.getElementById('bits-select').value);
    const entropySlice = finalHash.slice(0, bitsRequested / 8);
    
    // Checksum: SHA256 da entropia, pegar primeiros N/32 bits
    const checksumHash = new Uint8Array(await sha256(entropySlice));
    const checksumBitsLen = bitsRequested / 32;
    
    // Converter tudo para bits (string binária para facilitar divisão)
    let binaryStr = "";
    for (let b of entropySlice) binaryStr += b.toString(2).padStart(8, '0');
    
    // Adicionar Checksum
    let checksumBin = "";
    for (let b of checksumHash) checksumBin += b.toString(2).padStart(8, '0');
    binaryStr += checksumBin.substring(0, checksumBitsLen);

    // Dividir em grupos de 11 bits
    const indices = [];
    for (let i = 0; i < binaryStr.length; i += 11) {
        const chunk = binaryStr.substring(i, i + 11);
        indices.push(parseInt(chunk, 2));
    }

    // Renderizar Índices
    const grid = document.getElementById('seed-grid');
    grid.innerHTML = '';
    indices.forEach((idx, i) => {
        const div = document.createElement('div');
        div.className = 'seed-index';
        // A prompt pede variação de 1 a 2048. O índice cru é 0-2047.
        // Mostraremos o valor técnico do índice + 1 para cumprir o requisito visual
        // mas é importante saber que a wordlist começa em 0.
        div.innerHTML = `<span>#${i+1}</span><strong>${idx + 1}</strong>`; 
        grid.appendChild(div);
    });
    document.getElementById('bip39-panel').style.display = 'block';

    // 6. Geração de Chaves (Simplificada: Entropy Hash -> PrivKey)
    // Nota: Em BIP-32 real, usaríamos PBKDF2 na Mnemonic para obter a Seed Mestra,
    // depois HMAC-SHA512. Para este script single-file focado em auditoria e "geração",
    // usaremos o hash final (entropy) diretamente como Chave Privada (formato raw 32 bytes).
    // Isso é matematicamente seguro, apenas pula a derivação hierárquica complexa.
    
    const privKeyInt = BigInt('0x' + bufferToHex(finalHash));
    
    // Chave Pública (Compressed: 0x02 se Y par, 0x03 se Y ímpar + X)
    const pubPoint = SECP256K1.pointMultiply(privKeyInt);
    const pubX = pubPoint[0];
    const pubY = pubPoint[1];
    const prefix = (pubY % 2n === 0n) ? '02' : '03';
    const pubKeyHex = prefix + pubX.toString(16).padStart(64, '0');
    const pubKeyBytes = hexToBytes(pubKeyHex);

    // Address Generation (Legacy P2PKH)
    // 1. SHA-256 da PubKey
    const h1 = await sha256(pubKeyBytes);
    // 2. RIPEMD-160 do resultado
    const h2 = ripemd160(new Uint8Array(h1));
    // 3. Adicionar prefixo 0x00 (Mainnet)
    const payload = new Uint8Array(21);
    payload[0] = 0x00;
    payload.set(h2, 1);
    // 4. Checksum (Double SHA-256)
    const c1 = await sha256(payload);
    const c2 = await sha256(c1);
    const checksum = new Uint8Array(c2).slice(0, 4);
    // 5. Concatenar + Base58
    const addressBytes = new Uint8Array(25);
    addressBytes.set(payload);
    addressBytes.set(checksum, 21);
    const btcAddress = toBase58(addressBytes);

    // WIF Generation (Wallet Import Format)
    // 1. PrivKey + 0x80 (Mainnet) + 0x01 (Compressed flag)
    const wifPayload = new Uint8Array(34); // 1 + 32 + 1
    wifPayload[0] = 0x80;
    wifPayload.set(finalHash, 1);
    wifPayload[33] = 0x01;
    // Checksum
    const wc1 = await sha256(wifPayload);
    const wc2 = await sha256(wc1);
    const wChecksum = new Uint8Array(wc2).slice(0, 4);
    // Concatenar + Base58
    const wifBytes = new Uint8Array(38);
    wifBytes.set(wifPayload);
    wifBytes.set(wChecksum, 34);
    const wifStr = toBase58(wifBytes);

    // Exibir Chaves
    document.getElementById('out-priv-hex').innerText = bufferToHex(finalHash);
    document.getElementById('out-priv-wif').innerText = wifStr;
    document.getElementById('out-pub-hex').innerText = pubKeyHex;
    document.getElementById('out-address').innerText = btcAddress;
    document.getElementById('keys-panel').style.display = 'block';
}
</script>


</body></html>